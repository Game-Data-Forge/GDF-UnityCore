#region Copyright

// Game-Data-Forge Solution
// Written by CONTART Jean-François & BOULOGNE Quentin
// GDFFoundation.csproj GDFDebugAssembler.cs create at 2025/06/25 14:06:45
// ©2024-2025 idéMobi SARL FRANCE

#endregion

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;

namespace GDFFoundation
{
    /// <summary>
    /// Provides functionality for assembling and managing debug logs.
    /// The <see cref="GDFDebugAssembler"/> class allows logging of messages with additional context such as file name, method name, line number, timestamps, and elapsed time.
    /// </summary>
    public class GDFDebugAssembler
    {
        /// <summary>
        /// A collection of string log entries managed by the <see cref="GDFDebugAssembler"/> class.
        /// This variable is used internally to store log messages added via the <see cref="GDFDebugAssembler.Add(string, string, string, int)"/> method.
        /// </summary>
        private List<string> _items = new List<string>();

        /// <summary>
        /// A collection of headers used by the <see cref="GDFDebugAssembler"/> class.
        /// This variable is intended to store string identifiers or title information
        /// related to debug logs generated through methods such as <see cref="GDFDebugAssembler.Add(string, string[])"/>.
        /// </summary>
        public List<string> Headers = new List<string>();

        /// <summary>
        /// Represents the maximum size (in characters) allocated for file names when formatting log entries in the <see cref="GDFDebugAssembler"/>.
        /// </summary>
        const int _SIZE_FILE = 28;

        /// <summary>
        /// Represents the size limit for method names used in the formatting logic within the <see cref="GDFDebugAssembler"/> class.
        /// </summary>
        const int _SIZE_METHOD = 28;

        /// <summary>
        /// Represents the fixed size in characters allocated for displaying the line number
        /// in the debug messages generated by the <see cref="GDFDebugAssembler"/> class.
        /// </summary>
        const int _SIZE_LINE = 5;

        /// <summary>
        /// Represents the constant value used to define the size allocation
        /// in characters for time-related values when generating debug log entries
        /// in the <see cref="GDFDebugAssembler"/> class.
        /// </summary>
        const int _SIZE_TIME = 8;

        /// <summary>
        /// Represents the default maximum size allocated for a single debug log message within the <see cref="GDFDebugAssembler"/> class.
        /// This constant is used to standardize the character length of messages and ensures consistent formatting of logged entries.
        /// </summary>
        const int _SIZE_MESSAGE = 64;

        /// <summary>
        /// Represents the fixed size (in characters) used for formatting the time delta (Δ) column in the log entries.
        /// This value determines the space allocated for displaying the time difference between consecutive log entries in the <see cref="GDFDebugAssembler"/> output.
        /// </summary>
        const int _SIZE_DELTA = 7;

        /// <summary>
        /// Determines whether file names will be included in the output log of the <see cref="GDFDebugAssembler"/>.
        /// If set to <c>true</c>, the file name of the caller will be appended to each log entry.
        /// </summary>
        public bool UseFile = true;

        /// <summary>
        /// Determines whether method names will be included in log entries generated by the <see cref="GDFDebugAssembler"/> class.
        /// When set to <c>true</c>, the name of the calling method is appended to each log entry.
        /// </summary>
        public bool UseMethod = true;

        /// <summary>
        /// Indicates whether line number information should be included in debug output.
        /// When set to <c>true</c>, the debug output will include the line number of the code that invoked the debug action.
        /// This property is utilized within the <see cref="GDFDebugAssembler"/> class to format debug information.
        /// </summary>
        public bool UseLine = true;

        /// <summary>
        /// Represents the timestamp when the <see cref="GDFDebugAssembler"/> instance was initialized.
        /// This value serves as a reference point for calculating elapsed time in log entries.
        /// </summary>
        private DateTime _start = DateTime.UtcNow;

        /// <summary>
        /// Represents the timestamp of the last logging operation in the <see cref="GDFDebugAssembler"/> instance.
        /// This variable is updated every time a new log entry is added using the <see cref="GDFDebugAssembler.Add"/> method.
        /// It is used to calculate the time delta between consecutive log entries.
        /// </summary>
        private DateTime _step = DateTime.UtcNow;

        /// <summary>
        /// Adds the specified text to the collection with additional debug details.
        /// </summary>
        /// <param name="text">The text to add to the collection.</param>
        /// <param name="additionnal"></param>
        /// <param name="callerFile">The full path of the source file containing the caller. Provided by the <see cref="CallerFilePathAttribute"/>.</param>
        /// <param name="callerMethod">The name of the method or property that is calling this method. Provided by the <see cref="CallerMemberNameAttribute"/>.</param>
        /// <param name="callerLine">The line number in the source file at which this method is called. Provided by the <see cref="CallerLineNumberAttribute"/>.</param>
        public void Add(string text, string[] additionnal = null, [CallerFilePath] string callerFile = "", [CallerMemberName] string callerMethod = "", [CallerLineNumber] int callerLine = 0)
        {
            AddPrivate(text, additionnal, callerFile, callerMethod, callerLine);
        }

        /// <summary>
        /// Adds a detailed log entry to the internal collection, including contextual information.
        /// </summary>
        /// <param name="text">The main text or message to include in the log entry.</param>
        /// <param name="additionnal">Additional log information, where each entry corresponds to a defined header column.</param>
        /// <param name="callerFile">The full path of the source file containing the caller. Provided by the <see cref="CallerFilePathAttribute"/>.</param>
        /// <param name="callerMethod">The name of the method or property that is calling this method. Provided by the <see cref="CallerMemberNameAttribute"/>.</param>
        /// <param name="callerLine">The line number in the source file at which this method is called. Provided by the <see cref="CallerLineNumberAttribute"/>.</param>
        private void AddPrivate(string text, string[] additionnal, string callerFile, string callerMethod, int callerLine)
        {
            StringBuilder lineRow = new();
            lineRow.Append("| ");

            if (UseFile)
            {
                var fileName = Path.GetFileName(callerFile);
                if (fileName.Length > _SIZE_FILE)
                {
                    fileName = fileName.Substring(0, _SIZE_FILE);
                }

                lineRow.Append($"{fileName,-_SIZE_FILE} | "); // align left
            }

            if (UseMethod)
            {
                if (callerMethod.Length > _SIZE_METHOD)
                {
                    callerMethod = callerMethod.Substring(0, _SIZE_METHOD);
                }

                lineRow.Append($"{callerMethod,-_SIZE_METHOD} | "); // max 24 chars, left aligned
            }

            if (UseLine)
            {
                lineRow.Append($"{callerLine,_SIZE_LINE} | "); // right aligned
            }

            var now = DateTime.UtcNow;
            var totalMs = (int)(now - _start).TotalMilliseconds;
            var deltaMs = (int)(now - _step).TotalMilliseconds;
            lineRow.Append($"{totalMs,_SIZE_TIME} ms | {deltaMs,_SIZE_DELTA} ms | ");

            for (int i = 0; i < Headers.Count; i++)
            {
                string txt = "";
                if (additionnal != null && additionnal.Length > i)
                {
                    txt = additionnal[i];
                }

                if (txt.Length > Headers[i].Length)
                {
                    txt = txt.Substring(0, Headers[i].Length);
                }

                lineRow.Append($"{txt.PadLeft(Headers[i].Length)} | "); // align left
            }

            _step = now;

            lineRow.Append($"{text}");
            _items.Add(lineRow.ToString());
        }

        /// <summary>
        /// Adds a formatted title to the debug log with additional debug information.
        /// </summary>
        /// <param name="text">The text to format and add as a title to the debug log.</param>
        /// <param name="callerFile">
        /// The full path of the source file containing the caller. Provided by the <see cref="CallerFilePathAttribute"/>.
        /// </param>
        /// <param name="callerMethod">
        /// The name of the method or property that is calling this method. Provided by the <see cref="CallerMemberNameAttribute"/>.
        /// </param>
        /// <param name="callerLine">
        /// The line number in the source file at which this method is called. Provided by the <see cref="CallerLineNumberAttribute"/>.
        /// </param>
        public void AddTitle(string text, [CallerFilePath] string callerFile = "", [CallerMemberName] string callerMethod = "", [CallerLineNumber] int callerLine = 0)
        {
            AddPrivate(CenterTitle(text, _SIZE_MESSAGE), null, callerFile, callerMethod, callerLine);
        }

        /// <summary>
        /// Constructs a formatted log consisting of headers, separators, timestamps, and messages.
        /// The log includes information such as file name, method name, line number, timestamps, and message content,
        /// based on the configuration of the <see cref="GDFDebugAssembler"/> instance.
        /// </summary>
        /// <returns>An array of strings representing the formatted log, with each entry as a separate line.</returns>
        public string[] Result()
        {
            StringBuilder header = new("| ");
            StringBuilder sep = new("| ");
            DateTime now = DateTime.UtcNow;
            if (UseFile)
            {
                header.Append($"{"File",-_SIZE_FILE} | ");
                sep.Append(new string('-', _SIZE_FILE) + " | ");
            }

            if (UseMethod)
            {
                header.Append($"{"Method",-_SIZE_METHOD} | ");
                sep.Append(new string('-', _SIZE_METHOD) + " | ");
            }

            if (UseLine)
            {
                header.Append($"{"Line",_SIZE_LINE} | ");
                sep.Append(new string('-', _SIZE_LINE) + " | ");
            }

            header.Append($"   {"Time",_SIZE_TIME} |    {"Δ",_SIZE_DELTA} | ");
            sep.Append(new string('-', _SIZE_TIME) + "--- | ");
            sep.Append(new string('-', _SIZE_DELTA) + "--- | ");

            for (int i = 0; i < Headers.Count; i++)
            {
                header.Append($"{Headers[i]} | ");
                sep.Append(new string('-', Headers[i].Length) + " | ");
            }

            header.Append($"Message");
            sep.Append(new string('-', _SIZE_MESSAGE));

            _items.Insert(0, sep.ToString());
            _items.Insert(0, header.ToString());
            _items.Insert(0,
                $"Duration  : {(now - _start).TotalMilliseconds:0} ms");
            _items.Insert(0,
                $"End       : {now:yyyy-MM-dd HH:mm:ss.fff}");
            _items.Insert(0, 
                $"Start     : {_start:yyyy-MM-dd HH:mm:ss.fff}");
            _items.Insert(0, $"{nameof(GDFDebugAssembler)} item result");
            // area of real data
            _items.Add(sep.ToString());
            _items.Add(
                $"Start     : {_start:yyyy-MM-dd HH:mm:ss.fff}");
            _items.Add(
                $"End       : {now:yyyy-MM-dd HH:mm:ss.fff}");
            _items.Add(
                $"Duration  : {(now - _start).TotalMilliseconds:0} ms");

            return _items.ToArray();
        }

        /// <summary>
        /// Returns a string representation of the current state of the <see cref="GDFDebugAssembler"/> instance,
        /// including all added log entries with file name, method name, line number, timestamps, and messages.
        /// </summary>
        /// <returns>A string that represents the current state of the <see cref="GDFDebugAssembler"/> instance.</returns>
        public override string ToString()
        {
            return string.Join(Environment.NewLine, Result());
        }

        /// <summary>
        /// Clears all log entries from the current <see cref="GDFDebugAssembler"/> instance and resets the timing information.
        /// </summary>
        public void Clear()
        {
            _items.Clear();
            _start = _step = DateTime.UtcNow;
        }

        /// <summary>
        /// Centers the specified label within a string of a specified total width, padding with a specified character.
        /// If the label is too long to fit within the total width, it is truncated and appended with an ellipsis.
        /// </summary>
        /// <param name="label">The label to be centered within the output string.</param>
        /// <param name="totalWidth">The total width of the output string including the label and padding. Defaults to 64.</param>
        /// <param name="padChar">The character to use for padding on both sides of the label. Defaults to '-'.</param>
        /// <returns>A string where the label is centered with padding and truncated if necessary.</returns>
        public static string CenterTitle(string label, int totalWidth = 64, char padChar = '-')
        {
            label = label.Trim();

            // Si le texte est trop long, on le tronque et ajoute "…"
            if (label.Length + 2 > totalWidth) // +2 pour les espaces autour
            {
                label = label.Substring(0, totalWidth - 3) + "…";
            }

            int padTotal = totalWidth - label.Length - 2; // -2 pour les espaces
            int padLeft = padTotal / 2;
            int padRight = padTotal - padLeft;

            return new string(padChar, padLeft) + " " + label + " " + new string(padChar, padRight);
        }
    }
}